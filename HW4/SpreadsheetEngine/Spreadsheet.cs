// <copyright file="Spreadsheet.cs" company="Sher Chhi Ly">
// Copyright (c) Sher Chhi Ly. All rights reserved.
// </copyright>

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Formats.Asn1;
using System.Linq;
using System.Net;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;
using System.Threading.Tasks;
using System.Transactions;
using System.Xml;

namespace SpreadsheetEngine
{
    /// <summary>
    /// Purpose: will serve as a container for 2D array of cells, as a factory for cells.
    /// It is the entity that creates all the cells in the spreadsheet.
    /// The outside scope can only get a reference to the Cell class from the speadsheet object.
    /// </summary>
    public class Spreadsheet
    {
        /// <summary>
        /// Event field.
        /// </summary>
        public event PropertyChangedEventHandler CellPropertyChanged = (sender, e) => { };

        /// <summary>
        /// Private readonly variable.
        /// Remark: the readonly part was auto-generated by stylecops.
        /// </summary>
        private readonly Cell[,] arr2D;

        /// <summary>
        /// Most optimal structure compared to lists and stacks.
        /// Keeping track of cells that have been visited.
        /// </summary>
        private readonly HashSet<Cell> visitedCells = new HashSet<Cell>();

        /// <summary>
        /// Private accessibility (required).
        /// Stack for our undo action.
        /// </summary>
        private Stack<ICommands> undoStack = new Stack<ICommands>();

        /// <summary>
        /// Private accessibility (required).
        /// Stack for our redo action.
        /// </summary>
        private Stack<ICommands> redoStack = new Stack<ICommands>();

        /// <summary>
        /// Initializes a new instance of the <see cref="Spreadsheet"/> class.
        /// </summary>
        /// <param name="nRows"> number of rows to instantiate. </param>
        /// <param name="nColumns"> number of columns to instantiate. </param>
        public Spreadsheet(int nRows, int nColumns) // constructor
        {
            this.arr2D = new SpreadsheetCell[nRows, nColumns]; // initalizing the array of cells

            // we want to make sure that every cell is subcribed to an event change
            for (int i = 0; i < nRows; i++)
            {
                for (int j = 0; j < nColumns; j++)
                {
                    this.arr2D[i, j] = new SpreadsheetCell(i, j);
                    this.arr2D[i, j].PropertyChanged += UpdateCell;
                }
            }
        }

        /// <summary>
        /// Gets column count.
        /// </summary>
        public int ColumnCount
        {
            get
            {
                return this.arr2D.GetLength(0);
            }
        }

        /// <summary>
        /// Gets row count.
        /// </summary>
        public int RowCount
        {
            get
            {
                return this.arr2D.GetLength(0);
            }
        }

        /// <summary>
        /// This function takes a row and column index and returns the cell at that location.
        /// </summary>
        /// <param name="rowIndex"> row we're locating. </param>
        /// <param name="columnIndex"> column we're locating. </param>
        /// <returns>.</returns>
        public Cell GetCell(int rowIndex, int columnIndex)
        {
            return this.arr2D[rowIndex, columnIndex];
        }

        /// <summary>
        /// A way for us to access the protected setter for Value in Cell.cs.
        /// </summary>
        /// <param name="obj"> cell class object parameter. </param>
        /// <param name="value"> some string value. </param>
        public void SetValue(Cell obj, string value)
        {
            if (obj != null)
            {
                obj.ValueInCell = value;
            }
        }

        /// <summary>
        /// Aux method to help us know if user can undo or not.
        /// </summary>
        /// <returns> t/f.</returns>
        public bool IsUnDoable()
        {
            return this.undoStack.Count > 0;
        }

        /// <summary>
        /// Aux method to help us know if user can redo or not.
        /// </summary>
        /// <returns> t/f.</returns>
        public bool IsReDoable()
        {
            return this.redoStack.Count > 0;
        }

        /// <summary>
        /// Adds a commant onto undo stack.
        /// </summary>
        /// <param name="action"> interface parameter.</param>
        public void AddUndo(ICommands action)
        {
            this.undoStack.Push(action);
            this.redoStack.Clear();
        }

        /// <summary>
        /// Undo method.
        /// </summary>
        public void Undo()
        {
            if (this.undoStack.Count > 0)
            {
                ICommands command = this.undoStack.Pop();
                command.UnExecute();
                this.redoStack.Push(command);
            }
        }

        /// <summary>
        /// Redo method.
        /// </summary>
        public void Redo()
        {
            if (this.redoStack.Count > 0)
            {
                ICommands command = this.redoStack.Pop();
                command.Execute();
                this.undoStack.Push(command);
            }
        }

        /// <summary>
        /// Approach: Option 1 (outlined in lecture)
        /// Implementing Save method in logic engine
        /// Pulls properties out of the cell
        /// Writes all the XML itself.
        /// </summary>
        /// <param name="stream"> Stream class type param (required).</param>
        public void SaveSpreadsheetFile(Stream stream)
        {
            XmlWriterSettings settings = new XmlWriterSettings();
            settings.Indent = true; // makes xml files more readable by adding whitespace

            try
            {
                using (XmlWriter writer = XmlWriter.Create(stream, settings))
                {
                    writer.WriteStartDocument(); // begin

                    // root element; cells will be the child elements
                    writer.WriteStartElement("spreadsheet");

                    // only selecting cells that have one or more non-default properties
                    foreach (var cell in this.arr2D)
                    {
                        // child element
                        if ((cell != null && !string.IsNullOrEmpty(cell.TextInCell)) || cell.BGColor != 0xFFFFFFFF) // og bg color is white.
                        {
                            writer.WriteStartElement("cell");
                            writer.WriteAttributeString("name", this.ConvertToCellName(cell.RowIndex, cell.ColumnIndex)); // aux 5

                            if (cell.BGColor != 0xFFFFFFFF)
                            {
                                writer.WriteAttributeString("background_color", cell.BGColor.ToString("X")); // convert to hexadecimal (uppercase) - "X"
                            }

                            if (!string.IsNullOrEmpty(cell.TextInCell))
                            {
                                writer.WriteElementString("cell_text", cell.TextInCell); // not an attribute, more of an element context.
                            }

                            writer.WriteEndElement();
                        }
                    }

                    writer.WriteEndElement(); // all the mumbo jumbo inside the spreadsheet
                    writer.WriteEndDocument(); // stream closed
                }
            }
            catch (Exception)
            {
            }
        }

        /// <summary>
        /// Approach: Option 1 (outlined in lecture)
        /// Implementing Load method in logic engine
        /// Pulls properties out of the files
        /// Sets them in the cells.
        /// </summary>
        /// <param name="stream"> Stream class type param (required).</param>
        public void LoadSpreadsheetFile(Stream stream)
        {
            this.ClearSpreadsheet(); // aux 6

            using (XmlReader reader = XmlReader.Create(stream))
            {
                string? loadCellName = null;
                string loadCellText = string.Empty; // default value
                uint loadUint = 0xFFFFFFFF; // default value

                while (reader.Read())
                {
                    try
                    {
                        if (reader.NodeType == XmlNodeType.Element && reader.Name == "cell")
                        {
                            loadCellName = reader.GetAttribute("name");

                            // note: values must be reset for cells
                            string? loadHexBG = reader.GetAttribute("background_color");
                            if (!string.IsNullOrEmpty(loadHexBG))
                            {
                                loadUint = Convert.ToUInt32(loadHexBG, 16); // convert hex string to uint
                            }
                            else
                            {
                                loadUint = 0xFFFFFFFF; // default to white if attribute is missing
                            }

                            loadCellText = string.Empty;

                            // there was an issue i had with self-closing tags
                            // who knew xmlwriter auto-generates this?
                            if (reader.IsEmptyElement)
                            {
                                // process the cell right away
                                if (loadCellName != null)
                                {
                                    // short form to return to variables
                                    (int actualRow, int actualCol) = this.ConvertFromCellName(loadCellName);

                                    Cell cell = this.arr2D[actualRow, actualCol];
                                    cell.BGColor = loadUint;
                                    cell.TextInCell = loadCellText;
                                }

                                continue; // skip to next element since this current was a self-closed tag
                            }
                        }
                        else if (reader.NodeType == XmlNodeType.Element && reader.Name == "cell_text")
                        {
                            loadCellText = reader.ReadElementContentAsString();
                        }

                        // note: had to wait until end of element until cell can be assigned
                        else if (reader.NodeType == XmlNodeType.EndElement && reader.Name == "cell")
                        {
                            if (loadCellName != null)
                            {
                                // short form to return to variables
                                (int actualRow, int actualCol) = this.ConvertFromCellName(loadCellName);

                                Cell cell = this.arr2D[actualRow, actualCol];
                                cell.BGColor = loadUint;
                                cell.TextInCell = loadCellText;
                            }
                        }
                    }
                    catch (Exception)
                    {
                    }
                }
            }
        }

        /// <summary>
        /// Method for property change.
        /// </summary>
        /// <param name="sender"> object sender.</param>
        /// <param name="e"> e value.</param>
        public void UpdateCell(object sender, PropertyChangedEventArgs e)
        {
            SpreadsheetCell updateCell;

            if (e.PropertyName == "ColorInCell") // added for background color update
            {
                updateCell = (SpreadsheetCell)sender;

                this.CellPropertyChanged(sender, e);
            }

            if (e.PropertyName == "TextInCell")
            {
                updateCell = (SpreadsheetCell)sender;

                this.visitedCells.Add(updateCell);

                // to consider circular reference

                // bool used to safe-check and have cell be considered for possible dependencies
                bool didValueChange = false;

                // added feature: handling of empty strings; undo bug.
                if (string.IsNullOrEmpty(updateCell.TextInCell) || updateCell.TextInCell[0] != '=') // also checks if the field in the cell begins with '='
                {
                    updateCell.ValueInCell = updateCell.TextInCell;
                    didValueChange = true;
                }
                else // updating and evaluating value in cell
                {
                    try
                    {
                        string formula = updateCell.TextInCell.Substring(1);

                        ExpressionTree expTree = new ExpressionTree(formula);

                        updateCell.ClearDependencies();

                        foreach (var cellVariable in this.ExtractCellVariables(formula)) // aux 1 here
                        {
                            Cell? referencedCell = this.FindCell(cellVariable); // aux 3 here

                            // self reference detection
                            this.CheckSelfReference(updateCell, referencedCell); // aux 8 here

                            // circular reference detection
                            this.CheckCircularReference(referencedCell); // aux 9 here

                            double cellValue = this.GetCellVarValue(cellVariable); // aux 2 here

                            expTree.SetVariable(cellVariable, cellValue); // list of variables now stored in variables (in expression tree)

                            if (referencedCell != null)
                            {
                                updateCell.AddReferenceCell(referencedCell);
                            }
                        }

                        // evaluation here
                        double result = expTree.Evaluate();

                        if (updateCell.ValueInCell != result.ToString()) // only if it differs from the current value
                        {
                            this.SetValue(updateCell, result.ToString());
                            didValueChange = true;
                        }

                        // else ignore
                    }
                    catch (Exception ex) // in-cell handling of exception messages
                    {
                        this.SetValue(updateCell, ex.Message);
                    }
                }

                if (didValueChange)
                {
                    foreach (var dependent in updateCell.Dependents) // checking for each dependent cells of the current cell
                    {
                        this.StartUpdate(dependent); // aux 4 here
                    }
                }

                this.CellPropertyChanged(sender, new PropertyChangedEventArgs("ValueInCell"));
                this.visitedCells.Clear(); // resets
            }
        }

        /// <summary>
        /// Auxiliary method 1 to help store/set cell variables.
        /// </summary>
        /// <param name="formula"> string type.</param>
        /// <returns> List of variables to be evaluated.</returns>
        private List<string> ExtractCellVariables(string formula)
        {
            List<string> cellVariables = new List<string>(); // stores only cell variables ex. 'A1', 'D5', etc.

            int i = 0;

            while (i < formula.Length) // simple parsing through the string
            {
                if (char.IsUpper(formula[i]))
                {
                    string cellVar = formula[i].ToString();

                    try
                    {
                        i++; // goes to next character

                        if (char.IsLetter(formula[i])) // checking for multi-letter variables
                        {
                            throw new Exception("ERROR: Does not support multi-letter variables - ExtractCellVariables()"); // !(badreference)
                        }

                        while (i < formula.Length && char.IsDigit(formula[i])) // if a number is encountered after letter
                        {
                            cellVar += formula[i];
                            i++; // continues

                            if (Convert.ToInt64(cellVar.Substring(1)) < 1 || Convert.ToInt64(cellVar.Substring(1)) > 50) // checking for valid rows
                            {
                                throw new Exception("ERROR: Row index out of bounds - ExtractCellVariables()"); // !(badreference)
                            }
                        }

                        if (cellVar.Length > 1) // once two characters consisting of one letter and one digit is formed
                        {
                            cellVariables.Add(cellVar); // add to list
                        }
                    }
                    catch (Exception)
                    {
                        throw new Exception("ERROR: Invalid Variable(s) - ExtractCellVariables()"); // !(badreference)
                    }
                }
                else // not letter is encountered yet
                {
                    i++;
                }
            }

            return cellVariables;
        }

        /// <summary>
        /// Auxiliary method 2 to fix the zero-based index issue.
        /// NAME CHANGED.
        /// </summary>
        /// <param name="cellVariable"> string type.</param>
        /// <returns> the value in the cell that was called.</returns>
        private double GetCellVarValue(string cellVariable)
        {
            // algorithm was in my previous homework
            // i just had to refactored it
            char copyCol = cellVariable[0];
            int copyRow = int.Parse(cellVariable.Substring(1));

            int updatedCol = copyCol - 'A';
            int updatedRow = copyRow - 1; // offset index handling

            if (this.arr2D[updatedRow, updatedCol].ValueInCell == string.Empty)
            {
                return 0;
            }
            else
            {
                return Convert.ToDouble(this.arr2D[updatedRow, updatedCol].ValueInCell);
            }

            // the code below is not needed for hw 10
            // try
            // {
            //     return Convert.ToDouble(this.arr2D[updatedRow, updatedCol].ValueInCell);
            // }
            // catch (Exception)
            // {
            //     throw new UndefinedVariableException($"ERROR: {cellReference} is not defined - GetCellRefValue()");
            // }
        }

        /// <summary>
        /// Auxiliary method 3.
        /// Essentially the reverse core logic implementation of GetCellRefValue.
        /// We're now tring to locate the cell based on string variable given.
        /// </summary>
        /// <param name="cellReference"> string type.</param>
        /// <returns> Indices of Cell reference.</returns>
        private Cell? FindCell(string cellReference)
        {
            int getColumn = cellReference[0] - 'A';

            if (int.TryParse(cellReference.Substring(1), out int getRow))
            {
                getRow--; // offset

                return this.arr2D[getRow, getColumn];
            }

            return null;
        }

        /// <summary>
        /// Auxiliary method 4.
        /// Initiates updating of dependent cells.
        /// Recursively reevaluates dependent cell to match referenced cell.
        /// </summary>
        /// <param name="cell"> Cell class type.</param>
        private void StartUpdate(Cell cell)
        {
            this.visitedCells.Clear();
            this.UpdateCell(cell, new PropertyChangedEventArgs("TextInCell"));
        }

        /// <summary>
        /// Auxiliary method 5
        /// For Save feature for HW9
        /// Converts given indices to give valid cell name.
        /// </summary>
        /// <param name="cellRow"> row index.</param>
        /// <param name="cellCol"> column index.</param>
        /// <returns> cell name ex. 'A1'.</returns>
        private string ConvertToCellName(int cellRow, int cellCol)
        {
            char colName = Convert.ToChar(cellCol + 65);
            int rowName = cellRow + 1;

            string cellName = colName + rowName.ToString();

            return cellName;
        }

        /// <summary>
        /// Auxiliary method 7
        /// For Load feature for HW9
        /// Converts cell name in the xml to an index that the computer can understand
        /// Back to zero-based index.
        /// </summary>
        /// <param name="cellName"> string eg. 'A1'.</param>
        /// <returns> row and col respective to cell.</returns>
        private (int row, int col) ConvertFromCellName(string cellName)
        {
            int actualCol = cellName[0] - 'A';
            int actualRow = int.Parse(cellName.Substring(1)) - 1;

            return (actualRow, actualCol);
        }

        /// <summary>
        /// Auxiliary method 6
        /// Resets Spreadsheet
        /// Required for Loading feature.
        /// </summary>
        private void ClearSpreadsheet()
        {
            // row
            for (int i = 0; i < this.arr2D.GetLength(0); i++)
            {
                // column
                for (int j = 0; j < this.arr2D.GetLength(1); j++)
                {
                    this.arr2D[i, j].TextInCell = string.Empty; // reverts back to empty cells
                    this.arr2D[i, j].BGColor = 0xFFFFFFFF; // reverts back to white backgrounds
                }
            }

            // Clear our undo/redo stacks
            this.undoStack.Clear();
            this.redoStack.Clear();
        }

        /// <summary>
        /// Auxiliary method 8
        /// To help detect self-references
        /// This is in the context of UpdateCell()
        /// Re-factoring.
        /// </summary>
        /// <param name="curCell"> current cell.</param>
        /// <param name="pointCell"> cell it's pointing to.</param>
        private void CheckSelfReference(Cell curCell, Cell pointCell)
        {
            if (pointCell == curCell)
            {
                int row = curCell.RowIndex;
                int col = curCell.ColumnIndex;
                string cellName = this.ConvertToCellName(row, col); // aux 5

                throw new Exception($"ERROR: Self-reference detected - {cellName} is referencing itself - UpdateCell()"); // !(selfreference)
            }
        }

        /// <summary>
        /// Auxiliary method 9
        /// To help detect circular references
        /// I wanted to utilize the HashSet I had at the very beginning
        /// This is in the context of UpdateCell()
        /// Re-factoring.
        /// </summary>
        /// <param name="cell"> the cell being referenced in UpdateCell().</param>
        /// <exception cref="Exception"> circular reference detected.</exception>
        private void CheckCircularReference(Cell cell)
        {
            if (this.visitedCells.Contains(cell)) // the referenced cell has been visited before
            {
                throw new Exception("ERROR: Circular reference detected - UpdateCell()"); // !(circularreference)
            }

            // else
            this.visitedCells.Add(cell);

            // looking into the referencedCell's list of referenced cells
            // who doesn't like recursion?
            foreach (var refreferencedCell in cell.ReferencedCells)
            {
                this.CheckCircularReference(refreferencedCell); // same process for each cell (if there is any).
            }
        }
    }
}